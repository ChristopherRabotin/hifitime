var searchIndex = {};
searchIndex["hifitime"] = {"doc":"hifitime 0.0.1","items":[[4,"Errors","hifitime","Errors handles all oddities which may occur in this library.",null,null],[13,"Carry","","Carry is returned when a provided function does not support time carry. For example, if a call to `Datetime::new` receives 60 seconds and there are only 59 seconds in the provided date time then a Carry Error is returned as the Result.",0,null],[0,"instant","","The `instant` module is built on top of `std::time::Duration`. It is the basis of almost all computations in this library. It is the only common denominator allowing for conversions between Time Systems.",null,null],[3,"Duration","hifitime::instant","A `Duration` type to represent a span of time, typically used for system timeouts.",null,null],[3,"Instant","","An `Instant` type represents an instant with respect to 01 Jan 1900 at midnight, as per the International Atomic Time (TAI) system.",null,null],[4,"Era","","An `Era` represents whether the associated `Instant` is before the TAI Epoch (01 Jan 1900, midnight) or afterwards. If it is before, than it's refered to as \"Past\", otherwise is in the \"Present\" era.",null,null],[13,"Past","","",1,null],[13,"Present","","",1,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"era"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"era"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"era"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"instant"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"bool"}}],[11,"le","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"bool"}}],[11,"gt","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"bool"}}],[11,"ge","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"bool"}}],[11,"new","","Creates a new `Instant` with respect to TAI Epoch: 01 January 1900, 00:00:00.0. All time systems are represented with respect to this epoch. Note: this constructor relies on the constructor for std::time::Duration; as such, refer to `std::time::Duration::new` for pertinent warnings and limitations.",2,{"inputs":[{"name":"u64"},{"name":"u32"},{"name":"era"}],"output":{"name":"instant"}}],[11,"duration","","Returns the Duration with respect to Epoch (past OR present), check the `era()`",2,{"inputs":[{"name":"self"}],"output":{"name":"duration"}}],[11,"secs","","Returns the number of seconds with respect to the epoch.",2,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"nanos","","Returns the number of nanoseconds of the given instant.",2,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"era","","Returns the Era associated with this instant, i.e. whether it's before or after the TAI Epoch.",2,{"inputs":[{"name":"self"}],"output":{"name":"era"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"bool"}}],[11,"add","","Adds a given `std::time::Duration` to an `Instant`.",2,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"instant"}}],[11,"sub","","Subtracts a given `std::time::Duration` from an `Instant`. # Examples",2,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"instant"}}],[0,"julian","hifitime","The `julian` module supports (Modified) Julian Days, which are heavily used in astronomy and its engineering friends.",null,null],[3,"ModifiedJulian","hifitime::julian","`ModifiedJulian` handles the Modified Julian Days as explained here.",null,null],[12,"days","","",3,null],[17,"DAYS_PER_YEAR","","`DAYS_PER_YEAR` corresponds to the number of days per year in the Julian calendar.",null,null],[17,"SECONDS_PER_DAY","","`SECONDS_PER_DAY` defines the number of seconds per day.",null,null],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"modifiedjulian"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"le","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"gt","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"ge","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"julian_days","","`julian_days` returns the true Julian days from epoch 01 Jan -4713, 12:00 as explained in \"Fundamentals of astrodynamics and applications\", Vallado et al. 4th edition, page 182, and on Wikipedia.",3,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"from_instant","","`from_instant` converts an `Instant` to a ModifiedJulian as detailed in Vallado et al. 4th edition, page 182.",3,{"inputs":[{"name":"instant"}],"output":{"name":"modifiedjulian"}}],[11,"into_instant","","`into_instant` returns an `Instant` from the ModifiedJulian.",3,{"inputs":[{"name":"self"}],"output":{"name":"instant"}}],[0,"datetime","hifitime","The `datetime` module supports conversions between seconds past TAI epoch and a Datetime struct. The main advantage (and challenge) is the inherent support for leap seconds. Refer to module documentation for leap second implementation details.",null,null],[3,"FixedOffset","hifitime::datetime","`FixedOffset` implements a time fixed offset of a certain number of hours with regard to UTC.",null,null],[3,"Datetime","","Datetime supports date time has used by most humans. All time zones are defined with respect to UTC. Moreover, `Datetime` inherently supports the past leap seconds, as reported by the IETF and NIST at here. NOTE: leap seconds cannot be predicted! This module will be updated as soon as possible after a new leap second has been announced. WARNING: The historical oddities with calendars are not yet supported.",null,null],[6,"Offset","","`Offset` is an alias of Instant. It contains the same kind of information, but is used in the context of defining an offset with respect to Utc.",null,null],[11,"neg","","",4,{"inputs":[{"name":"self"}],"output":{"name":"offset"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"east_with_hours","","`east_with_hours` returns an eastward offset (i.e. \"before\" the UTC time)",5,{"inputs":[{"name":"u64"}],"output":{"name":"offset"}}],[11,"west_with_hours","","`west_with_hours` returns an eastward offset (i.e. \"before\" the UTC time)",5,{"inputs":[{"name":"u64"}],"output":{"name":"offset"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"datetime"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"datetime"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"datetime"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",6,{"inputs":[{"name":"self"},{"name":"datetime"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",6,{"inputs":[{"name":"self"},{"name":"datetime"}],"output":{"name":"bool"}}],[11,"le","","",6,{"inputs":[{"name":"self"},{"name":"datetime"}],"output":{"name":"bool"}}],[11,"gt","","",6,{"inputs":[{"name":"self"},{"name":"datetime"}],"output":{"name":"bool"}}],[11,"ge","","",6,{"inputs":[{"name":"self"},{"name":"datetime"}],"output":{"name":"bool"}}],[11,"new","","Creates a new UTC-offsetted datetime, with support for all the leap seconds with respect to TAI. NOTE: UTC leap seconds may be confusing because several dates have the same number of seconds since TAI epoch. WARNING: Does not support automatic carry and will return an error if so. WARNING: Although `PartialOrd` is implemented for Utc, the ambiguity of leap seconds as explained elsewhere in this documentation may lead to odd results (cf. examples below).",6,{"inputs":[{"name":"i32"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u32"}],"output":{"generics":["datetime","errors"],"name":"result"}}],[11,"with_offset","","Creates a new Datetime with the specified UTC time offset. Works like `Datetime::new` in every way but it sets the UTC time offset to the one provided.",6,{"inputs":[{"name":"i32"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u32"},{"name":"offset"}],"output":{"generics":["datetime","errors"],"name":"result"}}],[11,"year","","Returns the year of this Datetime date time.",6,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"month","","Returns the month of this Datetime date time.",6,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"day","","Returns the day of this Datetime date time.",6,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"hour","","Returns the hour of this Datetime date time.",6,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"minute","","Returns the minute of this Datetime date time.",6,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"second","","Returns the second of this Datetime date time.",6,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[11,"nanos","","Returns the nanoseconds of this Datetime date time.",6,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"offset","","Returns the offset of this Datetime date time.",6,{"inputs":[{"name":"self"}],"output":{"name":"offset"}}],[11,"at_midnight","","Creates a new UTC date at midnight (i.e. hours = 0, mins = 0, secs = 0, nanos = 0)",6,{"inputs":[{"name":"i32"},{"name":"u8"},{"name":"u8"}],"output":{"generics":["datetime","errors"],"name":"result"}}],[11,"at_noon","","Creates a new UTC date at noon (i.e. hours = 12, mins = 0, secs = 0, nanos = 0)",6,{"inputs":[{"name":"i32"},{"name":"u8"},{"name":"u8"}],"output":{"generics":["datetime","errors"],"name":"result"}}],[11,"to_utc","","",6,{"inputs":[{"name":"self"}],"output":{"name":"datetime"}}],[11,"to_offset","","",6,{"inputs":[{"name":"self"},{"name":"offset"}],"output":{"name":"datetime"}}],[11,"from_instant","","`from_instant` converts an Instant to a Datetime with an offset of Utc (i.e zero).",6,{"inputs":[{"name":"instant"}],"output":{"name":"datetime"}}],[11,"into_instant","","`into_instant` returns an Instant from the Datetime while correcting for the offset.",6,{"inputs":[{"name":"self"}],"output":{"name":"instant"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"add","","Adds a given `std::time::Duration` to a `Datetime`.",6,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"datetime"}}],[11,"sub","","Adds a given `std::time::Duration` to a `Datetime`.",6,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"datetime"}}],[0,"durations","hifitime","The `durations` module provides helpers for initializing an `std::time::Duration`.",null,null],[5,"from_days","hifitime::durations","Returns a duration from the while number of days requested.",null,{"inputs":[{"name":"u64"}],"output":{"name":"duration"}}],[5,"from_hours","","Returns a duration from the while number of hours requested.",null,{"inputs":[{"name":"u64"}],"output":{"name":"duration"}}],[5,"from_mins","","Returns a duration from the while number of minutes requested.",null,{"inputs":[{"name":"u64"}],"output":{"name":"duration"}}],[8,"TimeSystem","hifitime","A `TimeSystem` enables the creation of system for measuring spans of time, such as UTC or Julian days.",null,null],[10,"from_instant","","Use this method to convert between different `TimeSystem` implementors.",7,{"inputs":[{"name":"instant"}],"output":{"name":"self"}}],[10,"into_instant","","Also use this method to convert between different `TimeSystem` implementors",7,{"inputs":[{"name":"self"}],"output":{"name":"instant"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","hifitime::instant","Creates a new `Duration` from the specified number of whole seconds and additional nanoseconds.",8,{"inputs":[{"name":"u64"},{"name":"u32"}],"output":{"name":"duration"}}],[11,"from_secs","","Creates a new `Duration` from the specified number of whole seconds.",8,{"inputs":[{"name":"u64"}],"output":{"name":"duration"}}],[11,"from_millis","","Creates a new `Duration` from the specified number of milliseconds.",8,{"inputs":[{"name":"u64"}],"output":{"name":"duration"}}],[11,"from_micros","","Creates a new `Duration` from the specified number of microseconds.",8,{"inputs":[{"name":"u64"}],"output":{"name":"duration"}}],[11,"as_secs","","Returns the number of whole seconds contained by this `Duration`.",8,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"subsec_nanos","","Returns the fractional part of this `Duration`, in nanoseconds.",8,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"checked_add","","Checked `Duration` addition. Computes `self + other`, returning [`None`] if overflow occurred.",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"generics":["duration"],"name":"option"}}],[11,"checked_sub","","Checked `Duration` subtraction. Computes `self - other`, returning [`None`] if the result would be negative or if underflow occurred.",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"generics":["duration"],"name":"option"}}],[11,"checked_mul","","Checked `Duration` multiplication. Computes `self * other`, returning [`None`] if overflow occurred.",8,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"generics":["duration"],"name":"option"}}],[11,"checked_div","","Checked `Duration` division. Computes `self / other`, returning [`None`] if `other == 0`.",8,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"generics":["duration"],"name":"option"}}],[11,"mul_assign","","",8,null],[11,"partial_cmp","","",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"le","","",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"gt","","",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"ge","","",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"add","","",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"duration"}}],[11,"default","","",8,{"inputs":[],"output":{"name":"duration"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"generics":["error"],"name":"result"}}],[11,"add_assign","","",8,null],[11,"div_assign","","",8,null],[11,"hash","","",8,null],[11,"mul","","",8,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"duration"}}],[11,"div","","",8,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"duration"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"duration"}}],[11,"sub_assign","","",8,null],[11,"sum","","",8,{"inputs":[{"name":"i"}],"output":{"name":"duration"}}],[11,"sum","","",8,{"inputs":[{"name":"i"}],"output":{"name":"duration"}}],[11,"cmp","","",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"ordering"}}],[11,"sub","","",8,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"duration"}}]],"paths":[[4,"Errors"],[4,"Era"],[3,"Instant"],[3,"ModifiedJulian"],[6,"Offset"],[3,"FixedOffset"],[3,"Datetime"],[8,"TimeSystem"],[3,"Duration"]]};
initSearch(searchIndex);
