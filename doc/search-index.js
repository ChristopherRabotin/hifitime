var searchIndex = {};
searchIndex["hifitime"] = {"doc":"hifitime 0.0.1","items":[[4,"Errors","hifitime","Errors handles all oddities which may occur in this library.",null,null],[13,"Carry","","Carry is returned when a provided function does not support time carry. For example, if a call to `Utc::new` receives 60 seconds and there are only 59 seconds in the provided date time then a Carry Error is returned as the Result.",0,null],[0,"instant","","The `instant` module is built on top of std::time::Duration. It is the basis of almost all computations in this library. It is the only common denominator allowing for conversions between Time Systems.",null,null],[3,"Duration","hifitime::instant","A `Duration` type to represent a span of time, typically used for system timeouts.",null,null],[3,"Instant","","An `Instant` type represents an instant with respect to 01 Jan 1900 at midnight, as per the International Atomic Time (TAI) system.",null,null],[4,"Era","","An `Era` represents whether the associated `Instant` is before the TAI Epoch (01 Jan 1900, midnight) or afterwards. If it is before, than it's refered to as \"Past\", otherwise is in the \"Present\" era.",null,null],[13,"Past","","",1,null],[13,"Present","","",1,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"era"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"era"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"era"}],"output":{"name":"option"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"instant"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"option"}}],[11,"lt","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"bool"}}],[11,"le","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"bool"}}],[11,"gt","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"bool"}}],[11,"ge","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"bool"}}],[11,"new","","Creates a new `Instant` with respect to TAI Epoch: 01 January 1900, 00:00:00.0. All time systems are represented with respect to this epoch. Note: this constructor relies on the constructor for std::time::Duration; as such, refer to https://doc.rust-lang.org/std/time/struct.Duration.html#method.new for pertinent warnings and limitations.",2,{"inputs":[{"name":"u64"},{"name":"u32"},{"name":"era"}],"output":{"name":"instant"}}],[11,"duration","","Returns the Duration with respect to Epoch (past OR present), check the `era()`",2,{"inputs":[{"name":"self"}],"output":{"name":"duration"}}],[11,"secs","","Returns the number of seconds with respect to the epoch.",2,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"nanos","","Returns the number of nanoseconds of the given instant.",2,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"era","","Returns the Era associated with this instant, i.e. whether it's before or after the TAI Epoch.",2,{"inputs":[{"name":"self"}],"output":{"name":"era"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"bool"}}],[11,"add","","Adds a given `std::time::Duration` to an `Instant`.",2,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"instant"}}],[11,"sub","","Subtracts a given `std::time::Duration` from an `Instant`. # Examples",2,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"instant"}}],[0,"julian","hifitime","The `julian` module supports (Modified) Julian Days, which are heavily used in astronomy and its engineering friends.",null,null],[3,"ModifiedJulian","hifitime::julian","`ModifiedJulian` handles the Modified Julian Days as explained here.",null,null],[12,"days","","",3,null],[17,"DAYS_PER_YEAR","","DAYS_PER_YEAR corresponds to the number of days per year in the Julian calendar. This is fixed.",null,null],[17,"SECONDS_PER_DAY","","SECONDS_PER_DAY defines the number of seconds per day.",null,null],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"modifiedjulian"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"option"}}],[11,"lt","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"le","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"gt","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"ge","","",3,{"inputs":[{"name":"self"},{"name":"modifiedjulian"}],"output":{"name":"bool"}}],[11,"julian_days","","`julian_days` returns the true Julian days from epoch 01 Jan -4713, 12:00 as explained in \"Fundamentals of astrodynamics and applications\", Vallado et al. 4th edition, page 182, and on Wikipedia.",3,{"inputs":[{"name":"self"}],"output":{"name":"f64"}}],[11,"from_instant","","`from_instant` converts an `Instant` to a ModifiedJulian as detailed in Vallado et al. 4th edition, page 182.",3,{"inputs":[{"name":"instant"}],"output":{"name":"modifiedjulian"}}],[11,"as_instant","","`as_instant` returns an `Instant` from the ModifiedJulian.",3,{"inputs":[{"name":"self"}],"output":{"name":"instant"}}],[0,"utc","hifitime","The `Utc` module supports conversions between Utc and other time systems. The main advantage (and challenge) is the inherent support for leap seconds. Refer to module documentation for leap second implementation details.",null,null],[3,"Utc","hifitime::utc","Utc is the interface between a time system and a time zone. All time zones are defined with respect to UTC. Moreover, Utc inherently supports the past leap seconds, as reported by the IETF and NIST at https://www.ietf.org/timezones/data/leap-seconds.list . NOTE: leap seconds cannot be predicted! This module will be updated as soon as possible after a new leap second has been announced. WARNING: The historical oddities with calendars are not yet supported. Moreover, despite the fields of Utc being public, it is strongly advised to use the `new` function to ensure proper bound checking and correct leap second support. If your code breaks because you're not using `new`, don't file a bug.",null,null],[12,"year","","",4,null],[12,"month","","",4,null],[12,"day","","",4,null],[12,"hour","","",4,null],[12,"minute","","",4,null],[12,"second","","",4,null],[12,"nanos","","",4,null],[6,"Offset","","Offset is an alias of Instant. It contains the same kind of information, but is used in the context of defining an offset with respect to Utc.",null,null],[8,"TimeZone","","TimeZone defines a timezone with respect to Utc.",null,null],[10,"utc_offset","","utc_offset returns the difference between a given TZ and UTC.",5,{"inputs":[],"output":{"name":"offset"}}],[10,"new","","",5,{"inputs":[{"name":"i32"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u32"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"utc"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"utc"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"utc"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",4,{"inputs":[{"name":"self"},{"name":"utc"}],"output":{"name":"option"}}],[11,"lt","","",4,{"inputs":[{"name":"self"},{"name":"utc"}],"output":{"name":"bool"}}],[11,"le","","",4,{"inputs":[{"name":"self"},{"name":"utc"}],"output":{"name":"bool"}}],[11,"gt","","",4,{"inputs":[{"name":"self"},{"name":"utc"}],"output":{"name":"bool"}}],[11,"ge","","",4,{"inputs":[{"name":"self"},{"name":"utc"}],"output":{"name":"bool"}}],[11,"utc_offset","","Returns the offset between this TimeZone and UTC. In this case, the offset is strictly zero.",4,{"inputs":[],"output":{"name":"offset"}}],[11,"new","","Creates a new UTC date, with support for all the leap seconds with respect to TAI. NOTE: UTC leap seconds may be confusing because several dates have the same number of seconds since TAI epoch. WARNING: Does not support automatic carry and will return an error if so. WARNING: Although `PartialOrd` is implemented for Utc, the ambiguity of leap seconds as explained elsewhere in this documentation may lead to odd results (cf. examples below).",4,{"inputs":[{"name":"i32"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u8"},{"name":"u32"}],"output":{"name":"result"}}],[11,"from_instant","","`from_instant` converts an Instant to a Utc.",4,{"inputs":[{"name":"instant"}],"output":{"name":"utc"}}],[11,"as_instant","","`as_instant` returns an Instant from the Utc.",4,{"inputs":[{"name":"self"}],"output":{"name":"instant"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[8,"TimeSystem","hifitime","A TimeSystem enables the creation of system for measuring spans of time, such as UTC or Julian days.",null,null],[10,"from_instant","","Use this method to convert between different `TimeSystem` implementors.",6,{"inputs":[{"name":"instant"}],"output":{"name":"self"}}],[10,"as_instant","","Also use this method to convert between different `TimeSystem` implementors",6,{"inputs":[{"name":"self"}],"output":{"name":"instant"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","hifitime::instant","Creates a new `Duration` from the specified number of whole seconds and additional nanoseconds.",7,{"inputs":[{"name":"u64"},{"name":"u32"}],"output":{"name":"duration"}}],[11,"from_secs","","Creates a new `Duration` from the specified number of whole seconds.",7,{"inputs":[{"name":"u64"}],"output":{"name":"duration"}}],[11,"from_millis","","Creates a new `Duration` from the specified number of milliseconds.",7,{"inputs":[{"name":"u64"}],"output":{"name":"duration"}}],[11,"as_secs","","Returns the number of whole seconds contained by this `Duration`.",7,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"subsec_nanos","","Returns the fractional part of this `Duration`, in nanoseconds.",7,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"checked_add","","Checked `Duration` addition. Computes `self + other`, returning [`None`] if overflow occurred.",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"option"}}],[11,"checked_sub","","Checked `Duration` subtraction. Computes `self - other`, returning [`None`] if the result would be negative or if underflow occurred.",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"option"}}],[11,"checked_mul","","Checked `Duration` multiplication. Computes `self * other`, returning [`None`] if overflow occurred.",7,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"option"}}],[11,"checked_div","","Checked `Duration` division. Computes `self / other`, returning [`None`] if `other == 0`.",7,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"option"}}],[11,"default","","",7,{"inputs":[],"output":{"name":"duration"}}],[11,"div_assign","","",7,null],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"sub","","",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"duration"}}],[11,"mul","","",7,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"duration"}}],[11,"add","","",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"duration"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"option"}}],[11,"lt","","",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"le","","",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"gt","","",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"ge","","",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"bool"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"duration"}}],[11,"sub_assign","","",7,null],[11,"hash","","",7,null],[11,"cmp","","",7,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"ordering"}}],[11,"div","","",7,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"duration"}}],[11,"mul_assign","","",7,null],[11,"add_assign","","",7,null],[11,"sum","","",7,{"inputs":[{"name":"i"}],"output":{"name":"duration"}}],[11,"sum","","",7,{"inputs":[{"name":"i"}],"output":{"name":"duration"}}]],"paths":[[4,"Errors"],[4,"Era"],[3,"Instant"],[3,"ModifiedJulian"],[3,"Utc"],[8,"TimeZone"],[8,"TimeSystem"],[3,"Duration"]]};
initSearch(searchIndex);
